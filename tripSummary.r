## tripSummary   #####################################################################################################################

## STEFFEN OPPEL, 2019

## this script provides a simple summary for the foraging trips of central place foraging animals
## direction can be provided from individual nests if desired (nests=TRUE), default is for colony (mean lat and long across all nests if specified)
## output is a table that provides trip length, distance, and direction for each trip


## Trips must be a SpatialPointsDataFrame generated by the tripSplit function
## Colony must be a DataFrame with Latitudes and Longitudes
#### IF nests=TRUE, Colony must be a DataFrame with ID (the same ID as in Trips), Latitudes and Longitudes
### modified 27 December 2016 to make function more robust to different data frame structure
### updated 9 January 2017 to allow non-numeric trip ID
### updated 6 March 2019 to include tidyverse implementation and indication of complete trips

                                       
tripSummary <- function(Trips, Colony=Colony, nests=FALSE)
  {
  
  pkgs <-c('sp', 'tidyverse', 'geosphere', 'lubridate')
  for(p in pkgs) {suppressPackageStartupMessages(require(p, quietly=TRUE, character.only=TRUE,warn.conflicts=FALSE))}
  

  if(!"Latitude" %in% names(Colony)) stop("Colony missing Latitude field")
  if(!"Longitude" %in% names(Colony)) stop("Colony missing Longitude field")


  ### SUMMARISE MAX DIST FROM COLONY AND TRIP TRAVELLING TIME FOR EACH TRIP
  
  ## helper function to calculate distance unless no previous location
  poss_dist <- possibly(geosphere::distm, otherwise = NA)
  
  ## all summary in one pipe
  trip_distances <- as.data.frame(Trips@data) %>% 
    filter(trip_id!=-1) %>%   ### this removes the non-trip locations
    nest(Longitude, Latitude, .key = "coords") %>%
    group_by(trip_id) %>%
    mutate(prev_coords = lag(coords)) %>%
    ungroup() %>%
    mutate(Dist = map2_dbl(coords, prev_coords, poss_dist)) %>%
    mutate(Dist=if_else(is.na(Dist),ColDist,Dist)) %>%
    mutate(count=1) %>%
    group_by(ID, trip_id) %>%
    summarise(n_locs=sum(count),
              departure=min(DateTime),
              return=max(DateTime),
              duration=ifelse("N" %in% unique(Returns),NA,((max(TrackTime)-min(TrackTime))/3600)),
              total_dist=sum(Dist, na.rm=T)/1000,
              max_dist=max(ColDist)/1000) %>%
    mutate(direction=0) %>%
    mutate(complete=ifelse(is.na(duration),"incomplete trip","complete trip"))
    

  ### LOOP OVER EACH INDIVIDUAL TRIP TO CALCULATE DIRECTION TO FURTHEST POINT FROM COLONY
  for (i in unique(trip_distances$trip_id)){			### removed as.numeric as this only works with numeric ID
    x<-Trips@data[Trips@data$trip_id==i,]
    maxdist<-cbind(x$Longitude[x$ColDist==max(x$ColDist)],x$Latitude[x$ColDist==max(x$ColDist)])
    if(dim(maxdist)[1]>1){maxdist<-maxdist[1,]}
    
    if(nests == TRUE) {origin<- Colony[match(unique(x$ID), Colony$ID),]}else{origin<-Colony}
    b<-bearing(origin,maxdist)			## great circle route bearing of trip
    trip_distances$direction[trip_distances$trip_id==i]<-(b + 360) %% 360  ## convert the azimuthal bearing to a compass direction
    #trip_distances$bearingRhumb[trip_distances$trip_id==i]<-bearingRhumb(origin,maxdist) 	## constant compass bearing of trip
  }
if("incomplete trip" %in% trip_distances$complete) warning("Some trips did not return to the specified return buffer around the colony. The return date given for these trips refers to the last location of the trip, and NOT the actual return time to the colony.")
return(trip_distances)
}