### move2KBA (Download and format Movebank data) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dataset <- move2KBA(MovebankID=621703893, User="bealhammar", Password="xxx")
data("boobies")
tracks <- boobies
colony <- tracks[1,] %>% dplyr::select(lon_colony,lat_colony) %>%
dplyr::rename(Longitude=lon_colony,Latitude=lat_colony)
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
unique(tracks$ID)
unique(tracks$ID)[1:5]
tracks %>% filter(ID %in% unique(tracks$ID)[1:5])
nrow(tracks %>% filter(ID %in% unique(tracks$ID)[1:5]))
nrow(tracks)
x <- tracks %>% filter(ID %in% unique(tracks$ID)[1:5])
unique(x$ID)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:5])
paste0("X_"tracks$ID)
paste0("X_", tracks$ID)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:5])
tracks$ID <- paste0("X", tracks$ID)
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
TripSum
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:6])
tracks$ID <- paste0("X", tracks$ID)
# tracks$ID <- paste0("X", tracks$ID, "2000")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
## 3. ####
### findScale (get average foraging range, a list of H-value options, and test whether desired grid cell for kernel estimation makes sense given movement scale/tracking resolution) ~~~~~~~~~~~~~~~
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
# HVALS <- findScale(Trips,
#   ARSscale = T,
#   Trip_summary = TripSum,
#   FPTscales = seq(1, frange),
#   plotPeaks = T,
#   findPeak = "Flexible"
# )
# HVALS
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
# KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = 0.5, Res=0.1, UDLev = 50, polyOut=F)
debug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
names(DataGroup)
UIDs <- unique(TripCoords$ID)
UIDs
k
KDEraster <- raster::stack(lapply(KDE, function(x) raster::raster(as(x,"SpatialPixelsDataFrame"), values=T)))
KDEraster
# assure only IDs with UDs are in tracking data
UDnames <- names(KDEraster)
UDnames
UIDs
UDnames
unique(TripCoords$ID)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
Result <- data.frame()
LoopN
LoopNr
LoopN =1
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
i
N
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=F)
Output
RanNum <- sample(UIDs, N, replace=F)
RanNum
NotSelected <- TripCoords[!TripCoords$ID %in% RanNum,]
SelectedTracks <- TripCoords[TripCoords$ID %in% RanNum,]
NotSelected
all(stringr::str_detect(names(KDEraster), pattern = "^X"))
all(stringr::str_detect(names(KDEraster), pattern = "X"))
all(stringr::str_detect(names(KDEraster), pattern = "/^X"))
all(stringr::str_detect(names(KDEraster), pattern = "[^X]"))
all(stringr::str_detect(names(KDEraster), pattern = "^X"))
Selected <- KDEraster[[paste("X", RanNum, sep = "")]]
paste("X", RanNum, sep = "")
all(stringr::str_detect(names(KDEraster), pattern = "^X"))
names(KDEraster)
gsub("^X", "", names(KDEraster))
names(KDEraster) <- gsub("^X", "", names(KDEraster))
names(KDEraster)
gsub("^X", "", names(KDEraster))
names(KDEraster) <- gsub("^X", "", names(KDEraster))
names(KDEraster)
gsub("^X", "", names(KDEraster))
c("^X",)
c(gsub("^X", "", names(KDEraster)))
?names
paste0("", names(KDEraster))
RanNum
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=F)
NotSelected <- TripCoords[!TripCoords$ID %in% RanNum,]
SelectedTracks <- TripCoords[TripCoords$ID %in% RanNum,]
all(stringr::str_detect(names(KDEraster), pattern = "^X"))
Selected <- KDEraster[[ RanNum ]]
Selected
KDEstack <- raster::stack(Selected)  # list of RasterLayers to RasterStack
KDEcmbnd <- raster::calc(KDEstack, mean)                 # arithmetic mean
### Calculating inclusion value, using Kernel surface ######
KDElev <- KDEcmbnd
pixArea <- raster::res(KDElev)[1]
### original ##
df <- data.frame(UD = raster::getValues(KDElev)) %>%
mutate(rowname = 1:length(raster::getValues(KDElev))) %>%
mutate(usage = .data$UD * (pixArea^2)) %>%
arrange(desc(.data$usage)) %>%
mutate(cumulUD = cumsum(.data$usage)) %>%
mutate(INSIDE = ifelse(.data$cumulUD < (UDLev/100), 1, NA)) %>%
arrange(.data$rowname) %>%
dplyr::select(.data$INSIDE)
names(KDEraster)
library(track2KBA)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:6])
# tracks$ID <- paste0("X", tracks$ID)
# tracks$ID <- paste0("X", tracks$ID, "2000")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
## 3. ####
### findScale (get average foraging range, a list of H-value options, and test whether desired grid cell for kernel estimation makes sense given movement scale/tracking resolution) ~~~~~~~~~~~~~~~
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
# HVALS <- findScale(Trips,
#   ARSscale = T,
#   Trip_summary = TripSum,
#   FPTscales = seq(1, frange),
#   plotPeaks = T,
#   findPeak = "Flexible"
# )
# HVALS
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
# plot(KDE.Surface$KDE.Surface[[4]]) # if polyOut=T
# plot(KDE.Surface[[1]])             # if polyOut=F
debug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
UIDs
UIDs
LoopN=1
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=F)
NotSelected <- TripCoords[!TripCoords$ID %in% RanNum,]
SelectedTracks <- TripCoords[TripCoords$ID %in% RanNum,]
RanNum
names(KDEraster)
all(stringr::str_detect(names(KDEraster), pattern = "^X"))
Selected <- KDEraster[[ RanNum ]]
all(stringr::str_detect(unique(TripCoords$ID), pattern = "^X"))
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
Result <- data.frame()
LoopN=1
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=F)
NotSelected <- TripCoords[!TripCoords$ID %in% RanNum,]
SelectedTracks <- TripCoords[TripCoords$ID %in% RanNum,]
all(stringr::str_detect(unique(TripCoords$ID), pattern = "^[0-9]"))
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[0-9]"))
unique(TripCoords$ID)
xx <- unique(TripCoords$ID)
xx <- paste0(xx, "X")
xx
xx <- unique(TripCoords$ID)
xx <- paste0("X", xx)
all(stringr::str_detect(unique(TripCoords$ID), pattern = "^[0-9]"))
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[^0-9]"))
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[0-9^]"))
xx <- paste0(xx, "X")
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[0-9^]"))
library(track2KBA)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:6])
# tracks$ID <- paste0("X", tracks$ID)
# tracks$ID <- paste0("X", tracks$ID, "2000")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
## 3. ####
### findScale (get average foraging range, a list of H-value options, and test whether desired grid cell for kernel estimation makes sense given movement scale/tracking resolution) ~~~~~~~~~~~~~~~
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
# HVALS <- findScale(Trips,
#   ARSscale = T,
#   Trip_summary = TripSum,
#   FPTscales = seq(1, frange),
#   plotPeaks = T,
#   findPeak = "Flexible"
# )
# HVALS
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
# plot(KDE.Surface$KDE.Surface[[4]]) # if polyOut=T
# plot(KDE.Surface[[1]])             # if polyOut=F
## 6. ####
### repAssess (Assess representativeness of tracked sample ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
debug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
undebug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
debug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
Result <- data.frame()
UIDs
LoopN=1
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=F)
NotSelected <- TripCoords[!TripCoords$ID %in% RanNum,]
SelectedTracks <- TripCoords[TripCoords$ID %in% RanNum,]
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[^0-9]"))
unique(TripCoords$ID)
stringr::str_detect(unique(TripCoords$ID), pattern = "[^0-9]")
stringr::str_detect(unique(TripCoords$ID), pattern = "[0-9]")
stringr::str_detect(unique(TripCoords$ID), pattern = "^0-9")
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[^0-9]"))
unique(TripCoords$ID)
all(stringr::str_detect(unique(TripCoords$ID), pattern = "[0-9]"))
all(stringr::str_detect(unique(TripCoords$ID), pattern = "^[0-9]"))
xx <- unique(TripCoords$ID)
xx <- paste0("X", xx)
xx
all(stringr::str_detect(xx, pattern = "^[0-9]"))
all(stringr::str_detect(xx, pattern = "[0-9]"))
all(stringr::str_detect(unique(TripCoords$ID), pattern = "^[0-9]"))
library(track2KBA)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:6])
# tracks$ID <- paste0("X", tracks$ID)
# tracks$ID <- paste0("X", tracks$ID, "2000")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
## 3. ####
### findScale (get average foraging range, a list of H-value options, and test whether desired grid cell for kernel estimation makes sense given movement scale/tracking resolution) ~~~~~~~~~~~~~~~
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
# HVALS <- findScale(Trips,
#   ARSscale = T,
#   Trip_summary = TripSum,
#   FPTscales = seq(1, frange),
#   plotPeaks = T,
#   findPeak = "Flexible"
# )
# HVALS
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
# plot(KDE.Surface$KDE.Surface[[4]]) # if polyOut=T
# plot(KDE.Surface[[1]])             # if polyOut=F
## 6. ####
### repAssess (Assess representativeness of tracked sample ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
debug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
undebug(repAssess)
debug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
undebug(repAssess)
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:6])
tracks$ID <- paste0("X", tracks$ID)
# tracks$ID <- paste0("X", tracks$ID, "2000")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
## 3. ####
### findScale (get average foraging range, a list of H-value options, and test whether desired grid cell for kernel estimation makes sense given movement scale/tracking resolution) ~~~~~~~~~~~~~~~
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
# HVALS <- findScale(Trips,
#   ARSscale = T,
#   Trip_summary = TripSum,
#   FPTscales = seq(1, frange),
#   plotPeaks = T,
#   findPeak = "Flexible"
# )
# HVALS
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
# plot(KDE.Surface$KDE.Surface[[4]]) # if polyOut=T
# plot(KDE.Surface[[1]])             # if polyOut=F
## 6. ####
### repAssess (Assess representativeness of tracked sample ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# debug(repAssess)
#
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
tracks <- boobies
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
tracks <- tracks %>% filter(ID %in% unique(tracks$ID)[1:6])
# tracks$ID <- paste0("X", tracks$ID)
tracks$ID <- paste0("X", tracks$ID, "_2000")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
frange <- median(TripSum$max_dist)
frange
c(min(TripSum$max_dist), max(TripSum$max_dist))
fduration <- median(TripSum$duration)
fduration
c(min(TripSum$duration), max(TripSum$duration))
## 3. ####
### findScale (get average foraging range, a list of H-value options, and test whether desired grid cell for kernel estimation makes sense given movement scale/tracking resolution) ~~~~~~~~~~~~~~~
HVALS <- findScale(Trips,
ARSscale = F,
Trip_summary = TripSum
)
HVALS
# HVALS <- findScale(Trips,
#   ARSscale = T,
#   Trip_summary = TripSum,
#   FPTscales = seq(1, frange),
#   plotPeaks = T,
#   findPeak = "Flexible"
# )
# HVALS
## 4. ####
Trips <- Trips[Trips$ColDist > 2, ] # remove trip start and end points near colony
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
# plot(KDE.Surface$KDE.Surface[[4]]) # if polyOut=T
# plot(KDE.Surface[[1]])             # if polyOut=F
## 6. ####
### repAssess (Assess representativeness of tracked sample ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# debug(repAssess)
#
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=10, UDLev=50, avgMethod="mean", Ncores = 2)
if( all(stringr::str_detect(unique(TripCoords$ID), pattern = "[^0-9]")) ){ # if ID lvls start with number, add X for indexing
Selected <- KDEraster[[paste("X", RanNum, sep = "")]]
} else {
Selected <- KDEraster[[ RanNum ]]
}
xx <- unique(TripCoords$ID)
xx <- paste0(xx, "X")
xx <- paste0("X", xx)
all(stringr::str_detect(xx, pattern = "^[0-9]"))
all(stringr::str_detect(xx, pattern = "[0-9]"))
library(track2KBA)
?repAssess
repr <- data.frame(out = 98.19)
?data.frame
install.packages("goodpractice")
library(goodpractice)
?gp
gp("track2KBA")
warnings()
?system.file
system.file("C:/Users/Martim Bill/Documents/track2iba")
system.file("C:/Users/Martim Bill/Documents/track2iba", package = "track2KBA")
devtools::install_github("BirdLifeInternational/track2kba", dependencies=TRUE) # add argument 'build_vignettes = FALSE' to speed it up
install.packages("ade4")
install.packages("ade4")
devtools::install_github("BirdLifeInternational/track2kba", dependencies=TRUE) # add argument 'build_vignettes = FALSE' to speed it up
install.packages("curl")
install.packages("curl")
devtools::install_github("BirdLifeInternational/track2kba", dependencies=TRUE) # add argument 'build_vignettes = FALSE' to speed it up
install.packages("raster")
install.packages("tidyselect")
install.packages("tidyselect")
gp("C:\Users\Martim Bill\Documents\R\win-library\3.6\track2KBA")
system.file("C:\Users\Martim Bill\Documents\R\win-library\3.6\track2KBA")
system.file("C:/Users/Martim Bill/Documents/R/win-library/3.6/track2KBA")
system.file()
?adehabitatHR::estUDm2spixdf()
library(track2KBA)
library(goodpractice)
library(track2KBA)
gp(track2KBA)
?gp
gp("track2KBA")
results(gp("track2KBA"))
checks(gp("track2KBA"))
gp(track2KBA)
gp("track2KBA")
?aes_string
