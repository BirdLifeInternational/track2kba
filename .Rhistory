sp::proj4string(x)
sp::crs(x)
sp::CRS(x)
is.projected(x)
sp::is.projected(sp)
sp::is.projected(x)
expect_true(
x <- projectTracks(Tracks=tracks_prj2), sp::is.projected(x)
)
expect_true(
sp::is.projected(projectTracks(Tracks=tracks_prj2))
)
)
expect_true(
sp::is.projected(projectTracks(Tracks=tracks.Wgs))
)
expect_s4_class(
projectTracks(Tracks=tracks.Wgs), class = "SpatialPointsDataFrame"
)
library(track2KBA)
library(track2KBA)
library(track2KBA)
library(track2KBA)
library(track2KBA)
data("boobies")
tracks <- boobies
colony <- tracks[1,] %>% dplyr::select(lon_colony,lat_colony) %>%
dplyr::rename(Longitude=lon_colony,Latitude=lat_colony)
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
TripSum <- tripSummary(Trips, Colony = colony, Nests = F)
TripSum
debug(findScale)
HVALS <- findScale(Trips,
ARSscale = T,
Trip_summary = TripSum
)
### working on a replacement for old scaleARS peak identification code ##
# turn rows into list of single row dfs
out_scales_list <- split(out_scales, seq(nrow(out_scales)))
out_scales_list <- setNames(split(out_scales, seq(nrow(out_scales))), rownames(out_scales))
# find all peaks for each individual (m is # of pnts either side of peak that has lower or equal value to focal point)
pks_list <- lapply(out_scales_list, function (x, m = peakWidth){
# x <- unlist(out_scales_list[[4]]) # single-row df to vector
x <- unlist(x, use.names = F) # single-row df to vector
shape <- diff(sign(diff(x, na.pad = FALSE)))
pks <- unlist( lapply(which(shape < 0), function(i){
z <- i - m + 1
z <- ifelse(z > 0, z, 1)
w <- i + m + 1
w <- ifelse(w < length(x), w, length(x))
if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(NULL)
}) )
# steepness around peak
steepness <- unlist( lapply(pks, function(i){
if(length(i) > 0) {
s <- sum(diff(x[(i - m) : i]), abs(diff(x[i : (i + m)]))) }
else { s <- NULL }
return(s)
}) )
pks       <- unlist(pks)    # all peaks
firstpeak <- pks[1]         # first peak
maxpeak   <- pks[pks %in% which( x == suppressWarnings(max(x[pks])) )] # max peak
steeppeak <- pks[which.max(steepness)] # steepest peak
pk_list <- list(allpeaks=pks, first=firstpeak, max=maxpeak, steep=steeppeak)
return(pk_list)
})
### working on a replacement for old scaleARS peak identification code ##
# turn rows into list of single row dfs
out_scales_list <- split(out_scales, seq(nrow(out_scales)))
out_scales_list <- setNames(split(out_scales, seq(nrow(out_scales))), rownames(out_scales))
# find all peaks for each individual (m is # of pnts either side of peak that has lower or equal value to focal point)
pks_list <- lapply(out_scales_list, function (x, m = peakWidth){
# x <- unlist(out_scales_list[[4]]) # single-row df to vector
x <- unlist(x, use.names = F) # single-row df to vector
shape <- diff(sign(diff(x, na.pad = FALSE)))
pks <- unlist( lapply(which(shape < 0), function(i){
z <- i - m + 1
z <- ifelse(z > 0, z, 1)
w <- i + m + 1
w <- ifelse(w < length(x), w, length(x))
if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(NULL)
}) )
# steepness around peak
steepness <- unlist( lapply(pks, function(i){
if(length(i) > 0) {
s <- sum(diff(x[(i - m) : i]), abs(diff(x[i : (i + m)]))) }
else { s <- NULL }
return(s)
}) )
pks       <- unlist(pks)    # all peaks
firstpeak <- pks[1]         # first peak
maxpeak   <- pks[pks %in% which( x == suppressWarnings(max(x[pks])) )] # max peak
steeppeak <- pks[which.max(steepness)] # steepest peak
pk_list <- list(allpeaks=pks, first=firstpeak, max=maxpeak, steep=steeppeak)
return(pk_list)
})
nulls <- unlist( lapply( pks_list, function(x) { return(is.null(x$allpeaks)) } ) )
if(length(nulls) > 0) {
message("No peak found for ID(s):",  paste(names(pks_list[nulls]), collapse=" ") )
}
nulls <- unlist( lapply( pks_list, function(x) { return(is.null(x$allpeaks)) } ) )
message("No peak found for ID(s):",  paste(names(pks_list[nulls]), collapse=" ") )
ars.scales <- unlist( lapply( pks_list, function(x) {
return(x[[findPeak]])
} ) )
pks_list[[1]]
all.scales <- unlist( lapply( pks_list, function(x) {
return(x[[allpeaks]])
} ) )
x <- pks_list[[1]]
x
x[["allpeaks"]]
x$allpeaks
all.scales <- unlist( lapply( pks_list, function(x) {
return(x$allpeaks)
} ) )
all.scales
plot(FPTscales)
plot(FPTscales, out_scales)
head(out_scales)
split(out_scales, seq(nrow(out_scales)))
out_scales[1,]
plot(FTPscales, out_scales[1,])
plot(FPTscales, out_scales[1,])
plot(FPTscales, out_scales[1,], type="l")
ars.scales
points(ars.scales, col=2)
vline(ars.scales, col=2)
abline(v=ars.scales, col=2)
?abline
is.list(out_scales)
lapply(out_scales, "[")
lapply(out_scales, "[,")
lapply(out_scales, function(x) [x,])
lapply(out_scales, function(x) print(x))
out_scales_list
plot(FPTscales, out_scales_list[[1]])
plot(FPTscales, out_scales_list[[1]], type="l")
points(out_scales_list[[2]])
points(FPTscales, out_scales_list[[2]])
out_scales_list[[2]]
max(out_scales_list)
max(out_scales)
min(out_scales)
plot(FPTscales, out_scales_list[[1]])
plot(FPTscales, out_scales_list[[1]], ylim=c(0, max(out_scales)), type="l")
points(FPTscales, out_scales_list[[2]])
points(FPTscales, out_scales_list[[2]], type="l")
lapply(out_scales_list, function(x){
points(x, type="l")
})
x <- out_scales_list[[3]]
points(x, type="l")
x
points(FPTscales, x, type="l")
lapply(out_scales_list, function(x){
points(FPTscales, x, type="l")
})
plot(FPTscales, out_scales_list[[1]], ylim=c(0, max(out_scales)), type="l")
lapply(out_scales_list, function(x){
points(FPTscales, x, type="l")
})
ablines(v = ars.scales, col=2)
abline(v = ars.scales, col=2)
abline(v = ars.scales, col="light grey")
abline(v = ars.scales, col="grey")
abline(v = AprScale, col="red")
AprScale <- round(median(ars.scales), 2)
HVALS$ARSscale <- AprScale
abline(v = AprScale, col="red")
abline(v = AprScale, col="red", lwd=2)
# print diagnostic plot
print(plot(FPTscales, out_scales_list[[1]],
ylim=c(0, max(out_scales)), type="l",
ylab="var(log FPT)"))
lapply(out_scales_list, function(x){
points(FPTscales, x, type="l")
})
library(track2KBA)
HVALS <- findScale(Trips,
ARSscale = T,
Trip_summary = TripSum
)
library(track2KBA)
HVALS <- findScale(Trips,
ARSscale = T,
Trip_summary = TripSum
)
library(track2KBA)
debug(findScale)
HVALS <- findScale(Trips,
ARSscale = T,
Trip_summary = TripSum
)
# print diagnostic plot
print(plot(FPTscales, out_scales_list[[1]],
ylim=c(0, max(out_scales)), type="l",
ylab="var(log FPT)"))
lapply(out_scales_list, function(x){
points(FPTscales, x, type="l")
})
print(abline(v = ars.scales, col="grey"))
HVALS <- findScale(Trips,
ARSscale = T,
Trip_summary = TripSum
)
HVALS
library(track2KBA)
library(track2KBA)
data("boobies")
tracks <- boobies
colony <- tracks[1,] %>% dplyr::select(lon_colony,lat_colony) %>%
dplyr::rename(Longitude=lon_colony,Latitude=lat_colony)
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
## 2a. ####
### tripSplit (split tracks in to discrete trips [and optionally filter]) ~~~~~~~~~~~~~
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
## 2b. ####
### tripSummary (summary of trip movements, by individual) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Trips <- subset(Trips, Trips$Returns == "Yes" )
Trips_prj <- projectTracks(Trips)
Trips <- tripSplit(Trips_prj, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
Trips <- tripSplit(Trips_prj@data, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
library(track2KBA)
HVALS <- findScale(Trips_prj,
ARSscale = T,
Trip_summary = TripSum
)
Trips_prj
findScale
debug(findScale)
HVALS <- findScale(Trips_prj,
ARSscale = T,
Trip_summary = TripSum
)
library(track2KBA)
Trips_prj <- projectTracks(Trips)
HVALS <- findScale(Trips_prj,
ARSscale = T,
Trip_summary = TripSum
)
HVALS
library(track2KBA)
## 4. ####
Trips_prj <- Trips_prj[Trips_prj$ColDist > 2, ] # remove trip start and end points near colony
indEffect <- IndEffectTest(Trips_prj, GroupVar="ID", tripID="trip_id", method="BA", Scale=HVALS$mag, nboots=10)
indEffect$`Kolmogorov-Smirnov`
IndEffectTest()
IndEffectTest
indEffect <- IndEffectTest(Trips_prj, GroupVar="ID", tripID="trip_id", method="BA", Scale=HVALS$mag, nboots=10)
indEffect$`Kolmogorov-Smirnov`
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
debug(estSpaceUse)
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
expand.grid(x=xrange,y=yrange)
proj4string(DataGroup)
DataGroup
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T, plot = T)
undebug(estSpaceUse)
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T, plot = T)
# KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = 0.5, Res=0.1, UDLev = 50, polyOut=F)
n <- length(KDE.Surface$KDE.Surface)
debug(estSpaceUse)
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T, plot = T)
KDE.Surface
unique(DataGroup$ID)
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T, plot = T)
debug(estSpaceUse)
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T, plot = T)
KDE.Surface
TripCoords
head(TripCoords)
## 5. ####
### estSpaceUse (Produce utilization distributions for each individual) ~~~~~~~~~~~~~~~
h <- HVALS$mag
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T, plot = T)
before <- Sys.time()
repr <- repAssess(Trips_prj, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
Sys.time() - before
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
Trips
KDE.Surface <- estSpaceUse(DataGroup=Trips, Scale = h, UDLev = 50, polyOut=T, plot = T)
before <- Sys.time()
repr <- repAssess(Trips_prj, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
Sys.time() - before
debug(repAssess)
before <- Sys.time()
repr <- repAssess(Trips_prj, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
Sys.time() - before
KDE
proj4string(KDE)
raster::projection(KDEraster)
proj4string(DataGroup)
identical(raster::projection(KDEraster), sp::proj4string(DataGroup)) {warning("Tracking data and KDE should have same projection")}
!identical(raster::projection(KDEraster), sp::proj4string(DataGroup))
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
?warning
debug(repAssess)
repr <- repAssess(Trips_prj, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
Result <- data.frame()
LoopN=1
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=FALSE)
NotSelected <- DataGroup[!DataGroup$ID %in% RanNum,]
SelectedTracks <- DataGroup[DataGroup$ID %in% RanNum,]
# if ID lvls start with number, add X for indexing
if( all(stringr::str_detect(unique(DataGroup$ID), pattern = "^[0-9]")) ){
Selected <- KDEraster[[paste("X", RanNum, sep = "")]]
} else {
Selected <- KDEraster[[ RanNum ]]
}
KDEcmbnd <- raster::calc(KDEstack, mean)                 # arithmetic mean
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=FALSE)
NotSelected <- DataGroup[!DataGroup$ID %in% RanNum,]
SelectedTracks <- DataGroup[DataGroup$ID %in% RanNum,]
Selected <- KDEraster[[paste("X", RanNum, sep = "")]]
Selected
KDEstack <- raster::stack(Selected)  # list of RasterLayers to RasterStack
KDEcmbnd <- raster::calc(KDEstack, mean)                 # arithmetic mean
### Calculating inclusion value, using Kernel surface ######
KDElev <- KDEcmbnd
pixArea <- raster::res(KDElev)[1]
### original ##
df <- data.frame(UD = raster::getValues(KDElev)) %>%
mutate(rowname = seq_len(length(raster::getValues(KDElev)))) %>%
mutate(usage = .data$UD * (pixArea^2)) %>%
arrange(desc(.data$usage)) %>%
mutate(cumulUD = cumsum(.data$usage)) %>%
mutate(INSIDE = ifelse(.data$cumulUD < (UDLev/100), 1, NA)) %>%
arrange(.data$rowname) %>%
dplyr::select(.data$INSIDE)
KDElev[] <- df$INSIDE
KDElev
NotSelected
repr <- repAssess(Trips, KDE=KDE.Surface$KDE.Surface, Iteration=1, UDLev=50, avgMethod="mean", Ncores = 2)
Result <- data.frame()
LoopN=1
N <- DoubleLoop$SampleSize[LoopN]
i <- DoubleLoop$Iteration[LoopN]
Output <- data.frame(SampleSize = N, InclusionMean = 0,Iteration=i)
RanNum <- sample(UIDs, N, replace=FALSE)
NotSelected <- DataGroup[!DataGroup$ID %in% RanNum,]
SelectedTracks <- DataGroup[DataGroup$ID %in% RanNum,]
Selected <- KDEraster[[paste("X", RanNum, sep = "")]]
KDEstack <- raster::stack(Selected)  # list of RasterLayers to RasterStack
KDEcmbnd <- raster::calc(KDEstack, mean)                 # arithmetic mean
### Calculating inclusion value, using Kernel surface ######
KDElev <- KDEcmbnd
pixArea <- raster::res(KDElev)[1]
### original ##
df <- data.frame(UD = raster::getValues(KDElev)) %>%
mutate(rowname = seq_len(length(raster::getValues(KDElev)))) %>%
mutate(usage = .data$UD * (pixArea^2)) %>%
arrange(desc(.data$usage)) %>%
mutate(cumulUD = cumsum(.data$usage)) %>%
mutate(INSIDE = ifelse(.data$cumulUD < (UDLev/100), 1, NA)) %>%
arrange(.data$rowname) %>%
dplyr::select(.data$INSIDE)
KDElev[] <- df$INSIDE
KDElev
NotSelected
# plot(KDElev)
Overlain_Raster <- raster::extract(KDElev, NotSelected)
Trips
length(unique(Trips@data$ID))>25
selectIDs <- unique(Trips@data$ID)[1:25]
plotdat <-  Trips@data %>% dplyr::filter(.data$ID %in% selectIDs)
TRACKPLOT <- plotdat %>% mutate(complete=ifelse(.data$Returns=="No","No","Yes")) %>%
arrange(.data$ID, .data$TrackTime) %>% # filter(ifelse... include condition to only show 20 Ind
ggplot(aes(.data$., x=.data$Longitude, y=.data$Latitude, col=.data$complete)) +
geom_path() +
geom_point(data=Colony, aes(x=.data$Longitude, y=.data$Latitude), col='red', shape=16, size=2) +
facet_wrap(ggplot2::vars(.data$ID)) +
theme(panel.background=element_rect(fill="white", colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(colour="black", fill="white"),
panel.border = element_blank())
TRACKPLOT <- plotdat %>% dplyr::mutate(complete=ifelse(.data$Returns=="No","No","Yes")) %>%
arrange(.data$ID, .data$TrackTime) %>% # filter(ifelse... include condition to only show 20 Ind
ggplot(aes(.data$., x=.data$Longitude, y=.data$Latitude, col=.data$complete)) +
geom_path() +
geom_point(data=Colony, aes(x=.data$Longitude, y=.data$Latitude), col='red', shape=16, size=2) +
facet_wrap(ggplot2::vars(.data$ID)) +
theme(panel.background=element_rect(fill="white", colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(colour="black", fill="white"),
panel.border = element_blank())
TRACKPLOT <- plotdat %>% dplyr::mutate(complete=ifelse(.data$Returns=="No","No","Yes")) %>%
dplyr::arrange(.data$ID, .data$TrackTime) %>% # filter(ifelse... include condition to only show 20 Ind
ggplot(aes(.data$., x=.data$Longitude, y=.data$Latitude, col=.data$complete)) +
geom_path() +
geom_point(data=Colony, aes(x=.data$Longitude, y=.data$Latitude), col='red', shape=16, size=2) +
facet_wrap(ggplot2::vars(.data$ID)) +
theme(panel.background=element_rect(fill="white", colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(colour="black", fill="white"),
panel.border = element_blank())
library(ggplot2)
TRACKPLOT <- plotdat %>% dplyr::mutate(complete=ifelse(.data$Returns=="No","No","Yes")) %>%
dplyr::arrange(.data$ID, .data$TrackTime) %>% # filter(ifelse... include condition to only show 20 Ind
ggplot(aes(.data$., x=.data$Longitude, y=.data$Latitude, col=.data$complete)) +
geom_path() +
geom_point(data=Colony, aes(x=.data$Longitude, y=.data$Latitude), col='red', shape=16, size=2) +
facet_wrap(ggplot2::vars(.data$ID)) +
theme(panel.background=element_rect(fill="white", colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(colour="black", fill="white"),
panel.border = element_blank())
Colony = colony
TRACKPLOT <- plotdat %>% dplyr::mutate(complete=ifelse(.data$Returns=="No","No","Yes")) %>%
dplyr::arrange(.data$ID, .data$TrackTime) %>% # filter(ifelse... include condition to only show 20 Ind
ggplot(aes(.data$., x=.data$Longitude, y=.data$Latitude, col=.data$complete)) +
geom_path() +
geom_point(data=Colony, aes(x=.data$Longitude, y=.data$Latitude), col='red', shape=16, size=2) +
facet_wrap(ggplot2::vars(.data$ID)) +
theme(panel.background=element_rect(fill="white", colour="black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
strip.background = element_rect(colour="black", fill="white"),
panel.border = element_blank())
TRACKPLOT
?tripSplit
data("boobies")
tracks <- boobies
colony <- tracks[1,] %>% dplyr::select(lon_colony,lat_colony) %>%
dplyr::rename(Longitude=lon_colony,Latitude=lat_colony)
tracks <- formatFields(tracks, field_ID = "track_id", field_Lat="latitude", field_Lon="longitude", field_Date="date_gmt", field_Time="time_gmt")
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, plot=T, Nests = F, rmNonTrip = T)
Trips <- tripSplit(tracks, Colony=colony, InnerBuff=2, ReturnBuff=10, Duration=1, Nests = F, rmNonTrip = T)
tripmaps <- mapTrips(Trips)
tripmaps <- mapTrips(Trips, Colony=colony)
tripmaps
KDE.Surface
KDE <- KDE.Surface
### Polygon data ###
coordsets <- st_bbox(HR_sf)
UDPLOT <- ggplot(HR_sf) + geom_sf(data=HR_sf, aes(col=id), fill=NA) +
coord_sf(xlim = c(coordsets$xmin, coordsets$xmax), ylim = c(coordsets$ymin, coordsets$ymax), expand = TRUE) +
borders("world",fill=scales::alpha("dark grey", 0.7), colour="grey20") +
theme(panel.background=element_rect(fill="white", colour="black"),
axis.text=element_text(size=11, color="black"),
axis.title=element_text(size=14),
legend.position = "none") +
ylab("Latitude") +
xlab("Longitude")
HR_sf <- KDE.Surface
### Polygon data ###
coordsets <- st_bbox(HR_sf)
### Polygon data ###
coordsets <- sf::st_bbox(HR_sf)
HR_sf <- KDE.Surface$UDPolygons
### Polygon data ###
coordsets <- sf::st_bbox(HR_sf)
UDPLOT <- ggplot(HR_sf) + geom_sf(data=HR_sf, aes(col=id), fill=NA) +
coord_sf(xlim = c(coordsets$xmin, coordsets$xmax), ylim = c(coordsets$ymin, coordsets$ymax), expand = TRUE) +
borders("world",fill=scales::alpha("dark grey", 0.7), colour="grey20") +
theme(panel.background=element_rect(fill="white", colour="black"),
axis.text=element_text(size=11, color="black"),
axis.title=element_text(size=14),
legend.position = "none") +
ylab("Latitude") +
xlab("Longitude")
print(UDPLOT)
KDE.Surface$UDPolygons
class(KDE.Surface$UDPolygons)
type(KDE.Surface$UDPolygons)
class(KDE)[1]
class(KDE)
KDE <- KDE.Surface$UDPolygons
class(KDE)[1]
sf::st_is_simple(KDe)
sf::st_is_simple(KDE)
View(HR_sf)
KDE <- KDE.Surface$KDE.Surface
KDE
image(KDE)
class(KDE)
class(KDE)[1]
KDE.Surface$UDPolygons
KDE.Surface <- estSpaceUse(DataGroup=Trips_prj, Scale = h, UDLev = 50, polyOut=T)
kde_map <- mapKDE(KDE.Surface$UDPolygons)
kde_map
kde_map <- mapKDE(KDE.Surface$KDE.Surface)
kde_map
kde_map <- mapKDE(KDE.Surface$UDPolygons, Show=F)
ud_map <- mapKDE(KDE.Surface$KDE.Surface, Show=F)
ud_map
